name: Version Management & Release

on:
  workflow_dispatch:
    inputs:
      versionType:
        description: "Type of version increment"
        required: true
        default: "patch"
        type: choice
        options:
          - major
          - minor
          - patch
      createRelease:
        description: "Create a GitHub release after version bump"
        required: false
        default: true
        type: boolean

jobs:
  bump-version:
    name: Bump Version
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    outputs:
      new_version: ${{ steps.calc-version.outputs.package_version }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get Current Version
        id: get-version
        run: |
          CURRENT_VERSION=$(grep -o '<Version>[^<]*' src/RVToolsMerge/RVToolsMerge.csproj | sed 's/<Version>//')
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT

          # Handle complex versions with pre-release tags
          BASE_VERSION=$(echo "$CURRENT_VERSION" | cut -d'-' -f1)

          IFS='.' read -r MAJOR MINOR PATCH <<< "$BASE_VERSION"
          echo "major=$MAJOR" >> $GITHUB_OUTPUT
          echo "minor=$MINOR" >> $GITHUB_OUTPUT
          echo "patch=$PATCH" >> $GITHUB_OUTPUT

      - name: Calculate New Version
        id: calc-version
        run: |
          MAJOR=${{ steps.get-version.outputs.major }}
          MINOR=${{ steps.get-version.outputs.minor }}
          PATCH=${{ steps.get-version.outputs.patch }}

          # Validate numeric components are within .NET assembly version limits (0-65535)
          if ! [[ "$MAJOR" =~ ^[0-9]+$ ]] || [ "$MAJOR" -gt 65535 ] || [ "$MAJOR" -lt 0 ]; then
            echo "::error::Invalid major version: $MAJOR. Must be an integer between 0 and 65535."
            exit 1
          fi
          if ! [[ "$MINOR" =~ ^[0-9]+$ ]] || [ "$MINOR" -gt 65535 ] || [ "$MINOR" -lt 0 ]; then
            echo "::error::Invalid minor version: $MINOR. Must be an integer between 0 and 65535."
            exit 1
          fi
          if ! [[ "$PATCH" =~ ^[0-9]+$ ]] || [ "$PATCH" -gt 65535 ] || [ "$PATCH" -lt 0 ]; then
            echo "::error::Invalid patch version: $PATCH. Must be an integer between 0 and 65535."
            exit 1
          fi

          if [[ "${{ github.event.inputs.versionType }}" == "major" ]]; then
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
          elif [[ "${{ github.event.inputs.versionType }}" == "minor" ]]; then
            MINOR=$((MINOR + 1))
            PATCH=0
          else
            PATCH=$((PATCH + 1))
          fi

          # Revalidate after incrementing
          if [ "$MAJOR" -gt 65535 ]; then
            echo "::error::Major version would exceed 65535 after incrementing."
            exit 1
          fi
          if [ "$MINOR" -gt 65535 ]; then
            echo "::error::Minor version would exceed 65535 after incrementing."
            exit 1
          fi
          if [ "$PATCH" -gt 65535 ]; then
            echo "::error::Patch version would exceed 65535 after incrementing."
            exit 1
          fi

          # For both package and assembly base version
          PACKAGE_VERSION="$MAJOR.$MINOR.$PATCH"
          # For .NET assembly version (requires 4 components: major.minor.build.revision)
          # Using patch as build and 0 as revision
          ASSEMBLY_VERSION="$MAJOR.$MINOR.$PATCH.0"

          echo "package_version=$PACKAGE_VERSION" >> $GITHUB_OUTPUT
          echo "assembly_version=$ASSEMBLY_VERSION" >> $GITHUB_OUTPUT

          # Validate final package version format
          if ! [[ "$PACKAGE_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "::error::Invalid package version format: $PACKAGE_VERSION. Must be in format X.Y.Z"
            exit 1
          fi

      - name: Update Version in csproj
        run: |
          PACKAGE_VERSION="${{ steps.calc-version.outputs.package_version }}"
          ASSEMBLY_VERSION="${{ steps.calc-version.outputs.assembly_version }}"

          # Update the package version
          sed -i "s/<Version>.*<\/Version>/<Version>$PACKAGE_VERSION<\/Version>/g" src/RVToolsMerge/RVToolsMerge.csproj

          # Update assembly and file versions (must be strictly numeric with 4 parts)
          sed -i "s/<AssemblyVersion>.*<\/AssemblyVersion>/<AssemblyVersion>$ASSEMBLY_VERSION<\/AssemblyVersion>/g" src/RVToolsMerge/RVToolsMerge.csproj
          sed -i "s/<FileVersion>.*<\/FileVersion>/<FileVersion>$ASSEMBLY_VERSION<\/FileVersion>/g" src/RVToolsMerge/RVToolsMerge.csproj

          echo "::notice::Version updated from ${{ steps.get-version.outputs.current_version }} to package version $PACKAGE_VERSION (assembly version: $ASSEMBLY_VERSION)"

      - name: Create Version Update Branch
        id: create-branch
        run: |
          # Create a new branch for the version update
          VERSION_BRANCH="version-update-${{ steps.calc-version.outputs.package_version }}"
          git checkout -b $VERSION_BRANCH
          echo "branch_name=$VERSION_BRANCH" >> $GITHUB_OUTPUT
          git add src/RVToolsMerge/RVToolsMerge.csproj
          git config --local user.email "actions@github.com"
          git config --local user.name "GitHub Actions"
          git commit -m "chore: bump version to ${{ steps.calc-version.outputs.package_version }} [skip ci]"
          git push origin $VERSION_BRANCH

      - name: Create Pull Request
        id: create-pr
        run: |
          # Create a PR for the version update
          # Uses the GitHub CLI to create a pull request with the version changes
          # The PR title follows conventional commits format with "chore: bump version"
          # The PR description includes both the old and new version numbers for clarity
          PR_URL=$(gh pr create \
            --title "chore: bump version to ${{ steps.calc-version.outputs.package_version }}" \
            --body "This PR updates the version from ${{ steps.get-version.outputs.current_version }} to ${{ steps.calc-version.outputs.package_version }}." \
            --base "${{ github.ref_name }}" \
            --head "${{ steps.create-branch.outputs.branch_name }}")
          echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT
          # Extract the PR number from the URL for use in subsequent steps
          PR_NUMBER=$(echo $PR_URL | grep -o '[0-9]*$')
          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "::notice::Created PR for version update: $PR_URL"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Auto-Squash-Merge PR
        run: |
          # Attempt to automatically squash-merge the PR with retry logic
          # Some repositories may have required checks that need to complete
          # before merging is allowed, so we retry a few times with delays
          RETRIES=3
          RETRY_DELAY=300  # 5 minutes between retry attempts

          for i in $(seq 1 $RETRIES); do
            echo "Attempting to squash-merge PR (attempt $i of $RETRIES)..."
            if gh pr merge ${{ steps.create-pr.outputs.pr_number }} --squash --delete-branch; then
              echo "::notice::PR ${{ steps.create-pr.outputs.pr_number }} auto-squash-merged successfully."
              break
            else
              if [ $i -eq $RETRIES ]; then
                echo "::warning::Failed to auto-squash-merge PR after $RETRIES attempts. PR may need manual attention."
              else
                echo "Squash-merge attempt failed, waiting $RETRY_DELAY seconds before retrying..."
                sleep $RETRY_DELAY
              fi
            fi
          done
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create and Checkout Version Tag
        if: ${{ success() }}
        run: |
          # Wait a moment for the merge to complete
          # This small delay helps ensure the merge operation has fully completed
          sleep 30

          # Switch to main branch and update it with the latest changes
          git checkout main
          git pull origin main

          # Pull the latest changes after PR merge
          # This ensures we have the merged version update in our working directory
          git pull origin ${{ github.ref_name }}

          # Create a tag with the new version in format v1.0.0
          TAG_NAME="v${{ steps.calc-version.outputs.package_version }}"          # Check if tag already exists
          if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
            echo "::warning::Tag $TAG_NAME already exists, skipping tag creation"
          else
            git tag $TAG_NAME
            git push origin $TAG_NAME
            echo "::notice::Created tag $TAG_NAME"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build-release:
    name: Build Release Artifacts
    needs: bump-version
    if: ${{ success() && github.event.inputs.createRelease == 'true' }}
    uses: ./.github/workflows/build.yml
    permissions:
      contents: read
      actions: read
      checks: write
      pull-requests: read
    with:
      configuration: "Release"

  create-release:
    name: Create GitHub Release
    needs: [bump-version, build-release]
    if: ${{ success() && github.event.inputs.createRelease == 'true' }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Get Version from Previous Job
        id: get-version
        run: |
          # Get the version that was created in the bump-version job
          CURRENT_VERSION=$(grep -o '<Version>[^<]*' src/RVToolsMerge/RVToolsMerge.csproj | sed 's/<Version>//')
          echo "version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "::notice::Creating release for version $CURRENT_VERSION"

      - name: Download All Artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: List Downloaded Artifacts
        run: |
          echo "Downloaded artifacts:"
          find artifacts -type f -name "*" | head -20
          echo "Directory structure:"
          find artifacts -type d | head -10

      - name: Create Release Archives
        id: create-archives
        run: |
          mkdir -p release-files
          created_files=""

          # Function to create archive if directory exists and has files
          create_archive() {
            local platform=$1
            local artifact_pattern=$2
            local version=$3

            echo "Looking for artifacts matching pattern: $artifact_pattern"

            # Find the artifact directory
            artifact_dir=$(find artifacts -type d -name "*$artifact_pattern*" | head -1)

            if [[ -n "$artifact_dir" && -d "$artifact_dir" ]]; then
              file_count=$(find "$artifact_dir" -type f | wc -l)
              echo "Found artifact directory: $artifact_dir with $file_count files"

              if [[ $file_count -gt 0 ]]; then
                archive_name="RVToolsMerge-${version}-${platform}.zip"
                echo "Creating archive: $archive_name"

                cd "$artifact_dir"
                zip -r "../../release-files/$archive_name" . -x "*.pdb"
                cd - > /dev/null

                if [[ -f "release-files/$archive_name" ]]; then
                  echo "‚úÖ Successfully created $archive_name"
                  created_files="$created_files release-files/$archive_name"
                else
                  echo "::error::Failed to create $archive_name"
                fi
              else
                echo "::warning::No files found in $artifact_dir"
              fi
            else
              echo "::warning::No artifact directory found for pattern: $artifact_pattern"
            fi
          }

          # Create archives for each expected platform
          create_archive "win-x64" "windows" "${{ steps.get-version.outputs.version }}"
          create_archive "win-arm64" "windows-arm64" "${{ steps.get-version.outputs.version }}"
          create_archive "linux-x64" "linux" "${{ steps.get-version.outputs.version }}"
          create_archive "osx-arm64" "macos-arm64" "${{ steps.get-version.outputs.version }}"

          # Output created files for the release step
          echo "created_files=$created_files" >> $GITHUB_OUTPUT

          echo "Final release files:"
          ls -la release-files/ || echo "No release files created"

      - name: Validate Release Files
        run: |
          if [[ -z "${{ steps.create-archives.outputs.created_files }}" ]]; then
            echo "::error::No release files were created. Check build artifacts."
            exit 1
          fi

          echo "Validating release files..."
          for file in ${{ steps.create-archives.outputs.created_files }}; do
            if [[ -f "$file" ]]; then
              size=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null || echo "0")
              echo "‚úÖ $file (${size} bytes)"
            else
              echo "::error::Missing file: $file"
              exit 1
            fi
          done

      - name: Process Code Coverage (Windows x64 only)
        run: |
          echo "Processing code coverage from Windows x64 build..."

          # Look for the Windows code coverage report
          WIN_COVERAGE_DIR=$(find artifacts -type d -name "*code-coverage-report-windows*" | head -1)

          if [[ -n "$WIN_COVERAGE_DIR" && -d "$WIN_COVERAGE_DIR" ]]; then
            echo "Found Windows coverage directory: $WIN_COVERAGE_DIR"

            # Create a consolidated coverage directory
            mkdir -p release-coverage
            cp -r "$WIN_COVERAGE_DIR"/* release-coverage/ || echo "No coverage files to copy"

            echo "Code coverage processed successfully"
          else
            echo "::warning::Windows code coverage report not found"
          fi

      - name: Upload Code Coverage Report
        uses: actions/upload-artifact@v4
        with:
          name: release-code-coverage-report
          path: release-coverage
          retention-days: 30

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          name: RVToolsMerge v${{ steps.get-version.outputs.version }}
          tag_name: v${{ steps.get-version.outputs.version }}
          draft: false
          prerelease: ${{ contains(steps.get-version.outputs.version, '-') }}
          files: ${{ steps.create-archives.outputs.created_files }}
          fail_on_unmatched_files: true
          body: |
            ## RVToolsMerge v${{ steps.get-version.outputs.version }}

            A cross-platform tool for merging and processing RVTools Excel exports from VMware environments.

            ### üì• Downloads

            Choose the appropriate version for your operating system:

            | Platform | Architecture | Download |
            |----------|-------------|----------|
            | Windows | x64 | RVToolsMerge-${{ steps.get-version.outputs.version }}-win-x64.zip |
            | Windows | ARM64 | RVToolsMerge-${{ steps.get-version.outputs.version }}-win-arm64.zip |
            | Linux | x64 | RVToolsMerge-${{ steps.get-version.outputs.version }}-linux-x64.zip |
            | macOS | ARM64 (Apple Silicon) | RVToolsMerge-${{ steps.get-version.outputs.version }}-osx-arm64.zip |

            ### üöÄ Quick Start

            1. Download the archive for your platform
            2. Extract the archive to a directory of your choice
            3. Run the executable to start the interactive console interface
            4. Follow the prompts to select and merge your RVTools Excel files

            ### üìã What's Changed

            See the [CHANGELOG.md](https://github.com/${{ github.repository }}/blob/main/CHANGELOG.md) for detailed changes in this release.

            ### üêõ Issues & Support

            If you encounter any issues, please report them on our [Issues page](https://github.com/${{ github.repository }}/issues).

      - name: Cleanup
        if: always()
        run: |
          rm -rf artifacts release-files release-coverage
