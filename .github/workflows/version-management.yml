name: Version Management & Release

on:
  workflow_dispatch:
    inputs:
      versionType:
        description: "Type of version increment"
        required: true
        default: "patch"
        type: choice
        options:
          - major
          - minor
          - patch
      createRelease:
        description: "Create a GitHub release after version bump"
        required: false
        default: true
        type: boolean

jobs:
  bump-version:
    name: Bump Version
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      actions: write
    outputs:
      new_version: ${{ steps.calc-version.outputs.package_version }}
      pr_merged: ${{ steps.auto-merge.outputs.merge_success }}
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Get Current Version
        id: get-version
        run: |
          # Check if project file exists
          PROJECT_FILE="src/RVToolsMerge/RVToolsMerge.csproj"
          if [ ! -f "$PROJECT_FILE" ]; then
            echo "::error::Project file not found: $PROJECT_FILE"
            exit 1
          fi

          # Extract current version from project file
          CURRENT_VERSION=$(grep -o '<Version>[^<]*' "$PROJECT_FILE" | sed 's/<Version>//' | head -1)

          # Validate that version was extracted
          if [ -z "$CURRENT_VERSION" ]; then
            echo "::error::Could not extract version from $PROJECT_FILE"
            echo "Project file content:"
            head -30 "$PROJECT_FILE"
            exit 1
          fi

          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "::notice::Current version: $CURRENT_VERSION"

          # Handle complex versions with pre-release tags
          BASE_VERSION=$(echo "$CURRENT_VERSION" | cut -d'-' -f1)

          # Parse version components
          IFS='.' read -r MAJOR MINOR PATCH <<< "$BASE_VERSION"

          # Validate that all components were parsed
          if [ -z "$MAJOR" ] || [ -z "$MINOR" ] || [ -z "$PATCH" ]; then
            echo "::error::Failed to parse version components from: $BASE_VERSION"
            echo "Parsed: MAJOR='$MAJOR' MINOR='$MINOR' PATCH='$PATCH'"
            exit 1
          fi

          echo "major=$MAJOR" >> $GITHUB_OUTPUT
          echo "minor=$MINOR" >> $GITHUB_OUTPUT
          echo "patch=$PATCH" >> $GITHUB_OUTPUT
          echo "::notice::Parsed version components: MAJOR=$MAJOR, MINOR=$MINOR, PATCH=$PATCH"

      - name: Calculate New Version
        id: calc-version
        run: |
          MAJOR=${{ steps.get-version.outputs.major }}
          MINOR=${{ steps.get-version.outputs.minor }}
          PATCH=${{ steps.get-version.outputs.patch }}

          # Validate numeric components are within .NET assembly version limits (0-65535)
          if ! [[ "$MAJOR" =~ ^[0-9]+$ ]] || [ "$MAJOR" -gt 65535 ] || [ "$MAJOR" -lt 0 ]; then
            echo "::error::Invalid major version: $MAJOR. Must be an integer between 0 and 65535."
            exit 1
          fi
          if ! [[ "$MINOR" =~ ^[0-9]+$ ]] || [ "$MINOR" -gt 65535 ] || [ "$MINOR" -lt 0 ]; then
            echo "::error::Invalid minor version: $MINOR. Must be an integer between 0 and 65535."
            exit 1
          fi
          if ! [[ "$PATCH" =~ ^[0-9]+$ ]] || [ "$PATCH" -gt 65535 ] || [ "$PATCH" -lt 0 ]; then
            echo "::error::Invalid patch version: $PATCH. Must be an integer between 0 and 65535."
            exit 1
          fi

          if [[ "${{ github.event.inputs.versionType }}" == "major" ]]; then
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
          elif [[ "${{ github.event.inputs.versionType }}" == "minor" ]]; then
            MINOR=$((MINOR + 1))
            PATCH=0
          else
            PATCH=$((PATCH + 1))
          fi

          # Revalidate after incrementing
          if [ "$MAJOR" -gt 65535 ]; then
            echo "::error::Major version would exceed 65535 after incrementing."
            exit 1
          fi
          if [ "$MINOR" -gt 65535 ]; then
            echo "::error::Minor version would exceed 65535 after incrementing."
            exit 1
          fi
          if [ "$PATCH" -gt 65535 ]; then
            echo "::error::Patch version would exceed 65535 after incrementing."
            exit 1
          fi

          # For both package and assembly base version
          PACKAGE_VERSION="$MAJOR.$MINOR.$PATCH"
          # For .NET assembly version (requires 4 components: major.minor.build.revision)
          # Using patch as build and 0 as revision
          ASSEMBLY_VERSION="$MAJOR.$MINOR.$PATCH.0"

          echo "package_version=$PACKAGE_VERSION" >> $GITHUB_OUTPUT
          echo "assembly_version=$ASSEMBLY_VERSION" >> $GITHUB_OUTPUT

          # Validate final package version format
          if ! [[ "$PACKAGE_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "::error::Invalid package version format: $PACKAGE_VERSION. Must be in format X.Y.Z"
            exit 1
          fi

      - name: Update Version in csproj
        run: |
          PACKAGE_VERSION="${{ steps.calc-version.outputs.package_version }}"
          ASSEMBLY_VERSION="${{ steps.calc-version.outputs.assembly_version }}"
          PROJECT_FILE="src/RVToolsMerge/RVToolsMerge.csproj"

          echo "::notice::Updating $PROJECT_FILE with package version: $PACKAGE_VERSION, assembly version: $ASSEMBLY_VERSION"

          # Verify inputs
          if [ -z "$PACKAGE_VERSION" ] || [ -z "$ASSEMBLY_VERSION" ]; then
            echo "::error::Missing version values. PACKAGE_VERSION='$PACKAGE_VERSION' ASSEMBLY_VERSION='$ASSEMBLY_VERSION'"
            exit 1
          fi

          # Create backup of project file
          cp "$PROJECT_FILE" "$PROJECT_FILE.backup"

          # Update the package version
          if ! sed -i "s/<Version>.*<\/Version>/<Version>$PACKAGE_VERSION<\/Version>/g" "$PROJECT_FILE"; then
            echo "::error::Failed to update package version in $PROJECT_FILE"
            exit 1
          fi

          # Update assembly and file versions (must be strictly numeric with 4 parts)
          if ! sed -i "s/<AssemblyVersion>.*<\/AssemblyVersion>/<AssemblyVersion>$ASSEMBLY_VERSION<\/AssemblyVersion>/g" "$PROJECT_FILE"; then
            echo "::error::Failed to update assembly version in $PROJECT_FILE"
            exit 1
          fi

          if ! sed -i "s/<FileVersion>.*<\/FileVersion>/<FileVersion>$ASSEMBLY_VERSION<\/FileVersion>/g" "$PROJECT_FILE"; then
            echo "::error::Failed to update file version in $PROJECT_FILE"
            exit 1
          fi

          # Verify the changes were applied correctly
          echo "::group::Verifying version updates"
          UPDATED_PACKAGE=$(grep -o '<Version>[^<]*' "$PROJECT_FILE" | sed 's/<Version>//' | head -1)
          UPDATED_ASSEMBLY=$(grep -o '<AssemblyVersion>[^<]*' "$PROJECT_FILE" | sed 's/<AssemblyVersion>//' | head -1)
          UPDATED_FILE=$(grep -o '<FileVersion>[^<]*' "$PROJECT_FILE" | sed 's/<FileVersion>//' | head -1)

          echo "Updated package version: $UPDATED_PACKAGE"
          echo "Updated assembly version: $UPDATED_ASSEMBLY"
          echo "Updated file version: $UPDATED_FILE"

          if [ "$UPDATED_PACKAGE" != "$PACKAGE_VERSION" ]; then
            echo "::error::Package version update verification failed. Expected: $PACKAGE_VERSION, Got: $UPDATED_PACKAGE"
            exit 1
          fi

          if [ "$UPDATED_ASSEMBLY" != "$ASSEMBLY_VERSION" ]; then
            echo "::error::Assembly version update verification failed. Expected: $ASSEMBLY_VERSION, Got: $UPDATED_ASSEMBLY"
            exit 1
          fi

          if [ "$UPDATED_FILE" != "$ASSEMBLY_VERSION" ]; then
            echo "::error::File version update verification failed. Expected: $ASSEMBLY_VERSION, Got: $UPDATED_FILE"
            exit 1
          fi
          echo "::endgroup::"

          echo "::notice::Version updated successfully from ${{ steps.get-version.outputs.current_version }} to package version $PACKAGE_VERSION (assembly version: $ASSEMBLY_VERSION)"

      - name: Create Version Update Branch
        id: create-branch
        run: |
          # Create a new branch for the version update
          VERSION_BRANCH="version-update-${{ steps.calc-version.outputs.package_version }}"
          echo "::notice::Creating branch: $VERSION_BRANCH"

          # Configure Git user for commits
          git config --local user.email "actions@github.com"
          git config --local user.name "GitHub Actions"

          # Check if branch already exists and delete it if it does (cleanup from failed runs)
          if git show-ref --verify --quiet refs/remotes/origin/"$VERSION_BRANCH"; then
            echo "::warning::Branch $VERSION_BRANCH already exists remotely, deleting it"
            git push origin --delete "$VERSION_BRANCH" || echo "::warning::Failed to delete remote branch"
          fi

          # Create and switch to new branch
          git checkout -b "$VERSION_BRANCH"
          echo "branch_name=$VERSION_BRANCH" >> $GITHUB_OUTPUT

          # Add the modified project file
          git add src/RVToolsMerge/RVToolsMerge.csproj

          # Check if there are changes to commit
          if git diff --cached --quiet; then
            echo "::error::No changes to commit. Version update may have failed."
            git status
            exit 1
          fi

          # Commit the changes
          git commit -m "chore: bump version to ${{ steps.calc-version.outputs.package_version }} [skip ci]"

          # Push the branch
          if ! git push origin "$VERSION_BRANCH"; then
            echo "::error::Failed to push branch $VERSION_BRANCH"
            exit 1
          fi

          echo "::notice::Successfully created and pushed branch: $VERSION_BRANCH"

      - name: Create Pull Request
        id: create-pr
        run: |
          echo "::notice::Creating pull request for version update"

          # Check if PR already exists for this branch
          EXISTING_PR=$(gh pr list --head "${{ steps.create-branch.outputs.branch_name }}" --json number --jq '.[0].number' 2>/dev/null || echo "")

          if [ -n "$EXISTING_PR" ] && [ "$EXISTING_PR" != "null" ]; then
            echo "::warning::PR already exists for branch ${{ steps.create-branch.outputs.branch_name }}: #$EXISTING_PR"
            echo "pr_number=$EXISTING_PR" >> $GITHUB_OUTPUT
            echo "pr_url=https://github.com/${{ github.repository }}/pull/$EXISTING_PR" >> $GITHUB_OUTPUT
          else
            # Create new PR
            PR_URL=$(gh pr create \
              --title "chore: bump version to ${{ steps.calc-version.outputs.package_version }}" \
              --body "This PR updates the version from ${{ steps.get-version.outputs.current_version }} to ${{ steps.calc-version.outputs.package_version }}." \
              --base "${{ github.ref_name }}" \
              --head "${{ steps.create-branch.outputs.branch_name }}")

            if [ $? -ne 0 ] || [ -z "$PR_URL" ]; then
              echo "::error::Failed to create pull request"
              echo "Attempting to get more information..."
              gh pr list --head "${{ steps.create-branch.outputs.branch_name }}" || true
              exit 1
            fi

            echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT

            # Extract the PR number from the URL for use in subsequent steps
            PR_NUMBER=$(echo "$PR_URL" | grep -o '[0-9]*$')
            if [ -z "$PR_NUMBER" ]; then
              echo "::error::Failed to extract PR number from URL: $PR_URL"
              exit 1
            fi

            echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
            echo "::notice::Created PR for version update: $PR_URL (PR #$PR_NUMBER)"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Auto-Squash-Merge PR
        id: auto-merge
        run: |
          RETRIES=5
          RETRY_DELAY=60

          for i in $(seq 1 $RETRIES); do
            echo "Attempting to squash-merge PR (attempt $i of $RETRIES)..."

            PR_STATE=$(gh pr view ${{ steps.create-pr.outputs.pr_number }} --json mergeable,state --jq '.mergeable + "," + .state')
            echo "PR state: $PR_STATE"

            if gh pr merge ${{ steps.create-pr.outputs.pr_number }} --squash --delete-branch; then
              echo "::notice::PR ${{ steps.create-pr.outputs.pr_number }} auto-squash-merged successfully."
              echo "merge_success=true" >> $GITHUB_OUTPUT
              break
            else
              if [ $i -eq $RETRIES ]; then
                echo "::warning::Failed to auto-squash-merge PR after $RETRIES attempts. PR may need manual attention."
                echo "merge_success=false" >> $GITHUB_OUTPUT
              else
                echo "Squash-merge attempt failed, waiting $RETRY_DELAY seconds before retrying..."
                sleep $RETRY_DELAY
              fi
            fi
          done
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  create-tag:
    name: Create Version Tag
    needs: bump-version
    if: ${{ success() && needs.bump-version.outputs.pr_merged == 'true' }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      tag_created: ${{ steps.create-tag.outputs.tag_created }}
      tag_name: ${{ steps.create-tag.outputs.tag_name }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Create and Push Version Tag
        id: create-tag
        run: |
          echo "Waiting for merge to propagate..."
          EXPECTED_VERSION="${{ needs.bump-version.outputs.new_version }}"
          MAX_ATTEMPTS=10
          WAIT_INTERVAL=30

          for attempt in $(seq 1 $MAX_ATTEMPTS); do
            echo "Attempt $attempt of $MAX_ATTEMPTS: Checking for merged changes..."

            git fetch origin
            git checkout main
            git reset --hard origin/main
            git pull origin main

            CURRENT_VERSION_IN_FILE=$(grep -o '<Version>[^<]*' src/RVToolsMerge/RVToolsMerge.csproj | sed 's/<Version>//' || echo "NOT_FOUND")

            echo "Expected version: $EXPECTED_VERSION"
            echo "Version in file: $CURRENT_VERSION_IN_FILE"

            if [[ "$CURRENT_VERSION_IN_FILE" == "$EXPECTED_VERSION" ]]; then
              echo "‚úÖ Version verification successful!"
              break
            elif [[ $attempt -eq $MAX_ATTEMPTS ]]; then
              echo "::error::Version mismatch after $MAX_ATTEMPTS attempts! Expected $EXPECTED_VERSION but found $CURRENT_VERSION_IN_FILE"
              exit 1
            else
              echo "Version not yet updated, waiting $WAIT_INTERVAL seconds before retry..."
              sleep $WAIT_INTERVAL
            fi
          done

          TAG_NAME="v$EXPECTED_VERSION"

          if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
            echo "::error::Tag $TAG_NAME already exists. Cannot create duplicate version tag."
            exit 1
          fi

          git config --local user.email "actions@github.com"
          git config --local user.name "GitHub Actions"

          git tag -a "$TAG_NAME" -m "Release version $EXPECTED_VERSION"
          git push origin "$TAG_NAME"

          echo "::notice::Created and pushed tag $TAG_NAME pointing to commit $(git rev-parse HEAD)"
          echo "tag_created=true" >> $GITHUB_OUTPUT
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build-release:
    name: Build Release Artifacts
    needs: [bump-version, create-tag]
    if: ${{ success() && github.event.inputs.createRelease == 'true' && needs.create-tag.outputs.tag_created == 'true' }}
    uses: ./.github/workflows/build.yml
    permissions:
      contents: read
      actions: read
      checks: write
      pull-requests: read
    with:
      configuration: "Release"
      ref: ${{ needs.create-tag.outputs.tag_name }}

  create-release:
    name: Create GitHub Release
    needs: [bump-version, create-tag, build-release]
    if: ${{ success() && github.event.inputs.createRelease == 'true' && needs.create-tag.outputs.tag_created == 'true' }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: read
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          ref: ${{ needs.create-tag.outputs.tag_name }}

      - name: Get Version from Tag
        id: get-version
        run: |
          TAG_NAME="${{ needs.create-tag.outputs.tag_name }}"
          VERSION="${TAG_NAME#v}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "::notice::Creating release for version $VERSION from tag $TAG_NAME"

      - name: Download All Artifacts
        uses: actions/download-artifact@v6
        with:
          path: artifacts

      - name: List Downloaded Artifacts
        run: |
          echo "Downloaded artifacts:"
          find artifacts -type f | sort
          echo "Directory structure:"
          find artifacts -type d | sort

      - name: Create Release Archives
        id: create-archives
        run: |
          mkdir -p release-files
          created_files=""

          create_archive() {
            local platform=$1
            local artifact_name=$2
            local version=$3

            echo "Looking for artifact with name: $artifact_name"
            artifact_dir=$(find artifacts -type d -name "$artifact_name" | head -1)

            if [[ -n "$artifact_dir" && -d "$artifact_dir" ]]; then
              file_count=$(find "$artifact_dir" -type f | wc -l)
              echo "Found artifact directory: $artifact_dir with $file_count files"

              if [[ $file_count -gt 0 ]]; then
                archive_name="RVToolsMerge-${version}-${platform}.zip"
                archive_path="release-files/$archive_name"
                echo "Creating archive: $archive_name"

                cd "$artifact_dir"
                zip -r "../../$archive_path" . -x "*.pdb"
                cd - > /dev/null

                if [[ -f "$archive_path" ]]; then
                  echo "‚úÖ Successfully created $archive_name"
                  abs_path="$(pwd)/$archive_path"
                  if [[ -z "$created_files" ]]; then
                    created_files="$abs_path"
                  else
                    created_files="$created_files,$abs_path"
                  fi
                else
                  echo "::error::Failed to create $archive_name at $archive_path"
                fi
              else
                echo "::warning::No files found in $artifact_dir"
              fi
            else
              echo "::warning::No artifact directory found with name: $artifact_name"
            fi
          }

          VERSION_FROM_TAG="${{ steps.get-version.outputs.version }}"
          echo "Using version from tag: $VERSION_FROM_TAG"

          # Create ZIP archives for all platforms
          echo "Creating ZIP archives for all platforms..."
          create_archive "win-x64" "RVToolsMerge-win-x64" "$VERSION_FROM_TAG"
          create_archive "win-arm64" "RVToolsMerge-win-arm64" "$VERSION_FROM_TAG"
          create_archive "linux-x64" "RVToolsMerge-linux-x64" "$VERSION_FROM_TAG"
          create_archive "linux-arm64" "RVToolsMerge-linux-arm64" "$VERSION_FROM_TAG"
          create_archive "osx-arm64" "RVToolsMerge-osx-arm64" "$VERSION_FROM_TAG"

          echo "created_files=$created_files" >> $GITHUB_OUTPUT

          echo "Final release files:"
          ls -la release-files/ || echo "No release files created"

      - name: Validate Release Files
        run: |
          created_files="${{ steps.create-archives.outputs.created_files }}"
          VERSION_FROM_TAG="${{ steps.get-version.outputs.version }}"

          if [[ -z "$created_files" ]]; then
            echo "::error::No release files were created. Check build artifacts."
            exit 1
          fi

          echo "Validating release files..."
          IFS=',' read -ra FILE_ARRAY <<< "$created_files"
          for file in "${FILE_ARRAY[@]}"; do
            file=$(echo "$file" | xargs)
            if [[ -f "$file" ]]; then
              size=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null || echo "0")
              echo "‚úÖ $file (${size} bytes)"
            else
              echo "::error::Missing file: $file"
              exit 1
            fi
          done

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          name: RVToolsMerge v${{ steps.get-version.outputs.version }}
          tag_name: v${{ steps.get-version.outputs.version }}
          draft: false
          prerelease: ${{ contains(steps.get-version.outputs.version, '-') }}
          files: |
            release-files/*.zip
          fail_on_unmatched_files: true
          generate_release_notes: true
          body: |
            ## RVToolsMerge v${{ steps.get-version.outputs.version }}

            A cross-platform tool for merging and processing RVTools Excel exports from VMware environments.

            ### üì• Downloads

            Choose the appropriate version for your operating system:

            | Platform | Architecture | Download |
            |----------|-------------|----------|
            | Windows | x64 | RVToolsMerge-${{ steps.get-version.outputs.version }}-win-x64.zip |
            | Windows | ARM64 | RVToolsMerge-${{ steps.get-version.outputs.version }}-win-arm64.zip |
            | Linux | x64 | RVToolsMerge-${{ steps.get-version.outputs.version }}-linux-x64.zip |
            | Linux | ARM64 | RVToolsMerge-${{ steps.get-version.outputs.version }}-linux-arm64.zip |
            | macOS | ARM64 (Apple Silicon) | RVToolsMerge-${{ steps.get-version.outputs.version }}-osx-arm64.zip |

            ### üöÄ Quick Start

            1. Download the ZIP archive for your platform
            2. Extract the archive to a directory of your choice
            3. Run the executable file to start the application

            ### üìã What's Changed

            See the [CHANGELOG.md](https://github.com/${{ github.repository }}/blob/main/CHANGELOG.md) for detailed changes in this release.

            ### üêõ Issues & Support

            If you encounter any issues, please report them on our [Issues page](https://github.com/${{ github.repository }}/issues).

      - name: Cleanup
        if: always()
        run: |
          rm -rf artifacts release-files
